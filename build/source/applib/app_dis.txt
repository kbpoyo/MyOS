In archive /home/kbpoyo/code/cpp/MyOs/build/source/applib/libapp.a:

crt0.S.o:     file format elf32-i386
rw-r--r-- 0/0   1536 Jan  1 08:00 1970 crt0.S.o
architecture: i386, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000010  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000044  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000044  2**0
                  ALLOC
  3 .debug_line   0000004e  00000000  00000000  00000044  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
  4 .debug_line_str 00000066  00000000  00000000  00000092  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  5 .debug_info   00000024  00000000  00000000  000000f8  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
  6 .debug_abbrev 00000014  00000000  00000000  0000011c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_aranges 00000020  00000000  00000000  00000130  2**3
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
  8 .debug_str    0000006b  00000000  00000000  00000150  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
SYMBOL TABLE:
00000000 l    d  .text	00000000 .text
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_line_str	00000000 .debug_line_str
00000000 l    d  .debug_str	00000000 .debug_str
00000000 g       .text	00000000 _start
00000000         *UND*	00000000 cstart



Disassembly of section .text:

00000000 <_start>:
    .extern cstart
_start:
    //iret指令返回后，将之前压入的 ss,esp,eflags,cs,eip 寄存器值返回给对应寄存器，
	//由于cpu从0特权级切换到了3特权级，而之前其余的段寄存器都是0特权级，不能供3特权级使用，
	//所以cpu将其余寄存器置零，这里直接用ss寄存器再初始化其余段寄存器即可
	mov %ss, %ax
   0:	66 8c d0             	mov    %ss,%ax
	mov %ax, %ds
   3:	8e d8                	mov    %eax,%ds
	mov %ax, %es
   5:	8e c0                	mov    %eax,%es
	mov %ax, %fs
   7:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
   9:	8e e8                	mov    %eax,%gs

    //因为cs寄存器已由操作系统分配，所以直接跳转即可
	jmp cstart
   b:	e9 fc ff ff ff       	jmp    c <_start+0xc>
			c: R_386_PC32	cstart

cstart.c.o:     file format elf32-i386
rw-r--r-- 0/0   3084 Jan  1 08:00 1970 cstart.c.o
architecture: i386, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000003e  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000072  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000072  2**0
                  ALLOC
  3 .debug_info   00000114  00000000  00000000  00000072  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
  4 .debug_abbrev 000000ca  00000000  00000000  00000186  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  5 .debug_aranges 00000020  00000000  00000000  00000250  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
  6 .debug_line   00000064  00000000  00000000  00000270  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
  7 .debug_str    0000016a  00000000  00000000  000002d4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_line_str 0000010e  00000000  00000000  0000043e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .comment      0000002c  00000000  00000000  0000054c  2**0
                  CONTENTS, READONLY
 10 .note.GNU-stack 00000000  00000000  00000000  00000578  2**0
                  CONTENTS, READONLY
 11 .debug_frame  0000002c  00000000  00000000  00000578  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 cstart.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_line_str	00000000 .debug_line_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 g     F .text	0000003e cstart
00000000         *UND*	00000000 __bss_start__
00000000         *UND*	00000000 __bss_end__
00000000         *UND*	00000000 main
00000000         *UND*	00000000 exit



Disassembly of section .text:

00000000 <cstart>:
 * @brief 执行调用main之前的初始化工作
 *
 * @param argc
 * @param argv
 */
void cstart(int argc, char **argv) {
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 18             	sub    $0x18,%esp
    //对程序的bss段进行清零操作
    char *start = __bss_start__;
   6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			9: R_386_32	__bss_start__
    while (start < __bss_end__) {
   d:	eb 0c                	jmp    1b <cstart+0x1b>
        *(start++) = 0;
   f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  12:	8d 50 01             	lea    0x1(%eax),%edx
  15:	89 55 f4             	mov    %edx,-0xc(%ebp)
  18:	c6 00 00             	movb   $0x0,(%eax)
    while (start < __bss_end__) {
  1b:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
			1e: R_386_32	__bss_end__
  22:	72 eb                	jb     f <cstart+0xf>
    }
    
    exit(main(argc, argv));
  24:	83 ec 08             	sub    $0x8,%esp
  27:	ff 75 0c             	push   0xc(%ebp)
  2a:	ff 75 08             	push   0x8(%ebp)
  2d:	e8 fc ff ff ff       	call   2e <cstart+0x2e>
			2e: R_386_PC32	main
  32:	83 c4 10             	add    $0x10,%esp
  35:	83 ec 0c             	sub    $0xc,%esp
  38:	50                   	push   %eax
  39:	e8 fc ff ff ff       	call   3a <cstart+0x3a>
			3a: R_386_PC32	exit

lib_syscall.c.o:     file format elf32-i386
rw-r--r-- 0/0  10716 Jan  1 08:00 1970 lib_syscall.c.o
architecture: i386, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000003ce  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000402  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000402  2**0
                  ALLOC
  3 .debug_info   00000986  00000000  00000000  00000402  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
  4 .debug_abbrev 00000226  00000000  00000000  00000d88  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  5 .debug_aranges 00000020  00000000  00000000  00000fae  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
  6 .debug_line   00000266  00000000  00000000  00000fce  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
  7 .debug_str    000003b2  00000000  00000000  00001234  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_line_str 0000024e  00000000  00000000  000015e6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .comment      0000002c  00000000  00000000  00001834  2**0
                  CONTENTS, READONLY
 10 .note.GNU-stack 00000000  00000000  00000000  00001860  2**0
                  CONTENTS, READONLY
 11 .debug_frame  000002e0  00000000  00000000  00001860  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 lib_syscall.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_line_str	00000000 .debug_line_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 g     F .text	0000004c sys_call
0000004c g     F .text	0000002a msleep
00000076 g     F .text	0000001b getpid
00000091 g     F .text	00000028 print_msg
000000b9 g     F .text	0000001b fork
000000d4 g     F .text	0000002d execve
00000101 g     F .text	0000001b yield
0000011c g     F .text	00000027 open
00000143 g     F .text	0000002d read
00000170 g     F .text	0000002d write
0000019d g     F .text	00000021 close
000001be g     F .text	0000002d lseek
000001eb g     F .text	00000021 isatty
0000020c g     F .text	00000027 fstat
00000233 g     F .text	00000021 sbrk
00000254 g     F .text	00000021 dup
00000275 g     F .text	00000022 _exit
00000297 g     F .text	00000021 wait
000002b8 g     F .text	00000068 opendir
00000000         *UND*	00000000 malloc
00000000         *UND*	00000000 free
00000320 g     F .text	00000040 readdir
00000360 g     F .text	00000035 closedir
00000395 g     F .text	00000039 ioctl



Disassembly of section .text:

00000000 <sys_call>:
#include    "os_cfg.h"
#include    "lib_syscall.h"
#include    <stdlib.h>


int sys_call(syscall_args_t *args) {
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	57                   	push   %edi
   4:	56                   	push   %esi
   5:	53                   	push   %ebx
   6:	83 ec 10             	sub    $0x10,%esp
    // 传入远跳转需要的参数, 即cs = selector, eip = offset 
    //为调用门选择子赋予0特权级,调用门的 cpl 和 RPL <= 系统调用段描述符的DPL
    //门描述符中目标选择子的 CPL <= 门描述符的 DPL
    uint32_t addr[] = {0, SYSCALL_SELECTOR | 0};  
   9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  10:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%ebp)
        "push %[arg1]\n\t"
        "push %[arg0]\n\t"
        "push %[id]\n\t"
        "lcalll *(%[addr])\n\t"
        :"=a"(ret)
        :[arg3]"r"(args->arg3), 
  17:	8b 45 08             	mov    0x8(%ebp),%eax
  1a:	8b 40 10             	mov    0x10(%eax),%eax
         [arg2]"r"(args->arg2), 
  1d:	8b 55 08             	mov    0x8(%ebp),%edx
  20:	8b 52 0c             	mov    0xc(%edx),%edx
         [arg1]"r"(args->arg1),
  23:	8b 4d 08             	mov    0x8(%ebp),%ecx
  26:	8b 49 08             	mov    0x8(%ecx),%ecx
         [arg0]"r"(args->arg0), 
  29:	8b 5d 08             	mov    0x8(%ebp),%ebx
  2c:	8b 5b 04             	mov    0x4(%ebx),%ebx
         [id]"r"(args->id), 
  2f:	8b 75 08             	mov    0x8(%ebp),%esi
  32:	8b 36                	mov    (%esi),%esi
     __asm__ __volatile__(
  34:	8d 7d e8             	lea    -0x18(%ebp),%edi
  37:	50                   	push   %eax
  38:	52                   	push   %edx
  39:	51                   	push   %ecx
  3a:	53                   	push   %ebx
  3b:	56                   	push   %esi
  3c:	ff 1f                	lcall  *(%edi)
  3e:	89 45 f0             	mov    %eax,-0x10(%ebp)
         [addr]"r"(addr)
    );

    return ret;
  41:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
  44:	83 c4 10             	add    $0x10,%esp
  47:	5b                   	pop    %ebx
  48:	5e                   	pop    %esi
  49:	5f                   	pop    %edi
  4a:	5d                   	pop    %ebp
  4b:	c3                   	ret    

0000004c <msleep>:
/**
 * @brief 以ms为单位进行延时
 * 
 * @param ms 
 */
void msleep(int ms) {
  4c:	55                   	push   %ebp
  4d:	89 e5                	mov    %esp,%ebp
  4f:	83 ec 20             	sub    $0x20,%esp
    if (ms <= 0) return;
  52:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  56:	7e 1b                	jle    73 <msleep+0x27>

    syscall_args_t args;
    args.id = SYS_sleep;
  58:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    args.arg0 = ms;
  5f:	8b 45 08             	mov    0x8(%ebp),%eax
  62:	89 45 f0             	mov    %eax,-0x10(%ebp)

    sys_call(&args);
  65:	8d 45 ec             	lea    -0x14(%ebp),%eax
  68:	50                   	push   %eax
  69:	e8 fc ff ff ff       	call   6a <msleep+0x1e>
			6a: R_386_PC32	sys_call
  6e:	83 c4 04             	add    $0x4,%esp
  71:	eb 01                	jmp    74 <msleep+0x28>
    if (ms <= 0) return;
  73:	90                   	nop

}
  74:	c9                   	leave  
  75:	c3                   	ret    

00000076 <getpid>:
/**
 * @brief 获取用户进程id
 * 
 * @return int 
 */
int getpid(void) {
  76:	55                   	push   %ebp
  77:	89 e5                	mov    %esp,%ebp
  79:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_getpid;
  7c:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

    return sys_call(&args);
  83:	8d 45 ec             	lea    -0x14(%ebp),%eax
  86:	50                   	push   %eax
  87:	e8 fc ff ff ff       	call   88 <getpid+0x12>
			88: R_386_PC32	sys_call
  8c:	83 c4 04             	add    $0x4,%esp
}
  8f:	c9                   	leave  
  90:	c3                   	ret    

00000091 <print_msg>:

void print_msg(const char *fmt, int arg) {
  91:	55                   	push   %ebp
  92:	89 e5                	mov    %esp,%ebp
  94:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_printmsg;
  97:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
    args.arg0 = (int)fmt;
  9e:	8b 45 08             	mov    0x8(%ebp),%eax
  a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = arg;
  a4:	8b 45 0c             	mov    0xc(%ebp),%eax
  a7:	89 45 f4             	mov    %eax,-0xc(%ebp)

    sys_call(&args);
  aa:	8d 45 ec             	lea    -0x14(%ebp),%eax
  ad:	50                   	push   %eax
  ae:	e8 fc ff ff ff       	call   af <print_msg+0x1e>
			af: R_386_PC32	sys_call
  b3:	83 c4 04             	add    $0x4,%esp
}
  b6:	90                   	nop
  b7:	c9                   	leave  
  b8:	c3                   	ret    

000000b9 <fork>:

int fork (void) {
  b9:	55                   	push   %ebp
  ba:	89 e5                	mov    %esp,%ebp
  bc:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_fork;
  bf:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)

    return sys_call(&args);
  c6:	8d 45 ec             	lea    -0x14(%ebp),%eax
  c9:	50                   	push   %eax
  ca:	e8 fc ff ff ff       	call   cb <fork+0x12>
			cb: R_386_PC32	sys_call
  cf:	83 c4 04             	add    $0x4,%esp
}
  d2:	c9                   	leave  
  d3:	c3                   	ret    

000000d4 <execve>:
 * @param name 外部程序名
 * @param argv 外部程序的参数，字符串常量指针，即字符串数组，数组中的char*值为常量
 * @param env  所加载程序的环境变量
 * @return int 
 */
int execve(const char *name, char * const * argv, char * const * env) {
  d4:	55                   	push   %ebp
  d5:	89 e5                	mov    %esp,%ebp
  d7:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_execve;
  da:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%ebp)
    args.arg0 = (int)name;
  e1:	8b 45 08             	mov    0x8(%ebp),%eax
  e4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = (int)argv;
  e7:	8b 45 0c             	mov    0xc(%ebp),%eax
  ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2 = (int)env;
  ed:	8b 45 10             	mov    0x10(%ebp),%eax
  f0:	89 45 f8             	mov    %eax,-0x8(%ebp)


    return sys_call(&args);
  f3:	8d 45 ec             	lea    -0x14(%ebp),%eax
  f6:	50                   	push   %eax
  f7:	e8 fc ff ff ff       	call   f8 <execve+0x24>
			f8: R_386_PC32	sys_call
  fc:	83 c4 04             	add    $0x4,%esp
}
  ff:	c9                   	leave  
 100:	c3                   	ret    

00000101 <yield>:
/**
 * @brief 进程主动放弃cpu
 * 
 * @return int 
 */
int yield (void) {
 101:	55                   	push   %ebp
 102:	89 e5                	mov    %esp,%ebp
 104:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_yield;
 107:	c7 45 ec 04 00 00 00 	movl   $0x4,-0x14(%ebp)

    return sys_call(&args);
 10e:	8d 45 ec             	lea    -0x14(%ebp),%eax
 111:	50                   	push   %eax
 112:	e8 fc ff ff ff       	call   113 <yield+0x12>
			113: R_386_PC32	sys_call
 117:	83 c4 04             	add    $0x4,%esp
}
 11a:	c9                   	leave  
 11b:	c3                   	ret    

0000011c <open>:
 * @param name 
 * @param flags 
 * @param ... 
 * @return int 
 */
int open(const char *name, int flags, ...) {
 11c:	55                   	push   %ebp
 11d:	89 e5                	mov    %esp,%ebp
 11f:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_open;
 122:	c7 45 ec 32 00 00 00 	movl   $0x32,-0x14(%ebp)
    args.arg0 = (int)name;
 129:	8b 45 08             	mov    0x8(%ebp),%eax
 12c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = flags;
 12f:	8b 45 0c             	mov    0xc(%ebp),%eax
 132:	89 45 f4             	mov    %eax,-0xc(%ebp)

    return sys_call(&args);
 135:	8d 45 ec             	lea    -0x14(%ebp),%eax
 138:	50                   	push   %eax
 139:	e8 fc ff ff ff       	call   13a <open+0x1e>
			13a: R_386_PC32	sys_call
 13e:	83 c4 04             	add    $0x4,%esp
}
 141:	c9                   	leave  
 142:	c3                   	ret    

00000143 <read>:
 * @param file 
 * @param ptr 
 * @param len 
 * @return int 
 */
int read(int file, char *ptr, int len) {
 143:	55                   	push   %ebp
 144:	89 e5                	mov    %esp,%ebp
 146:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_read;
 149:	c7 45 ec 33 00 00 00 	movl   $0x33,-0x14(%ebp)
    args.arg0 = file;
 150:	8b 45 08             	mov    0x8(%ebp),%eax
 153:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = (int)ptr;
 156:	8b 45 0c             	mov    0xc(%ebp),%eax
 159:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2 = len;
 15c:	8b 45 10             	mov    0x10(%ebp),%eax
 15f:	89 45 f8             	mov    %eax,-0x8(%ebp)

    return sys_call(&args);
 162:	8d 45 ec             	lea    -0x14(%ebp),%eax
 165:	50                   	push   %eax
 166:	e8 fc ff ff ff       	call   167 <read+0x24>
			167: R_386_PC32	sys_call
 16b:	83 c4 04             	add    $0x4,%esp
}
 16e:	c9                   	leave  
 16f:	c3                   	ret    

00000170 <write>:
 * @param file 
 * @param ptr 
 * @param len 
 * @return int 
 */
int write(int file, char *ptr, int len) {
 170:	55                   	push   %ebp
 171:	89 e5                	mov    %esp,%ebp
 173:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_write;
 176:	c7 45 ec 34 00 00 00 	movl   $0x34,-0x14(%ebp)
    args.arg0 = file;
 17d:	8b 45 08             	mov    0x8(%ebp),%eax
 180:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = (int)ptr;
 183:	8b 45 0c             	mov    0xc(%ebp),%eax
 186:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2 = len;
 189:	8b 45 10             	mov    0x10(%ebp),%eax
 18c:	89 45 f8             	mov    %eax,-0x8(%ebp)

    return sys_call(&args);
 18f:	8d 45 ec             	lea    -0x14(%ebp),%eax
 192:	50                   	push   %eax
 193:	e8 fc ff ff ff       	call   194 <write+0x24>
			194: R_386_PC32	sys_call
 198:	83 c4 04             	add    $0x4,%esp
}
 19b:	c9                   	leave  
 19c:	c3                   	ret    

0000019d <close>:
 * @brief 关闭文件描述符
 * 
 * @param file 
 * @return int 
 */
int close(int file) {
 19d:	55                   	push   %ebp
 19e:	89 e5                	mov    %esp,%ebp
 1a0:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_close;
 1a3:	c7 45 ec 35 00 00 00 	movl   $0x35,-0x14(%ebp)
    args.arg0 = file;
 1aa:	8b 45 08             	mov    0x8(%ebp),%eax
 1ad:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return sys_call(&args);
 1b0:	8d 45 ec             	lea    -0x14(%ebp),%eax
 1b3:	50                   	push   %eax
 1b4:	e8 fc ff ff ff       	call   1b5 <close+0x18>
			1b5: R_386_PC32	sys_call
 1b9:	83 c4 04             	add    $0x4,%esp
}
 1bc:	c9                   	leave  
 1bd:	c3                   	ret    

000001be <lseek>:
 * @param file 
 * @param offset 
 * @param dir 
 * @return int 
 */
int lseek(int file, int offset, int dir) {
 1be:	55                   	push   %ebp
 1bf:	89 e5                	mov    %esp,%ebp
 1c1:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_lseek;
 1c4:	c7 45 ec 36 00 00 00 	movl   $0x36,-0x14(%ebp)
    args.arg0 = file;
 1cb:	8b 45 08             	mov    0x8(%ebp),%eax
 1ce:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = offset;
 1d1:	8b 45 0c             	mov    0xc(%ebp),%eax
 1d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2 = dir;
 1d7:	8b 45 10             	mov    0x10(%ebp),%eax
 1da:	89 45 f8             	mov    %eax,-0x8(%ebp)

    return sys_call(&args);
 1dd:	8d 45 ec             	lea    -0x14(%ebp),%eax
 1e0:	50                   	push   %eax
 1e1:	e8 fc ff ff ff       	call   1e2 <lseek+0x24>
			1e2: R_386_PC32	sys_call
 1e6:	83 c4 04             	add    $0x4,%esp
}
 1e9:	c9                   	leave  
 1ea:	c3                   	ret    

000001eb <isatty>:
 * @brief 
 * 
 * @param file 
 * @return int 
 */
int isatty(int file) {
 1eb:	55                   	push   %ebp
 1ec:	89 e5                	mov    %esp,%ebp
 1ee:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_isatty;
 1f1:	c7 45 ec 37 00 00 00 	movl   $0x37,-0x14(%ebp)
    args.arg0 = file;
 1f8:	8b 45 08             	mov    0x8(%ebp),%eax
 1fb:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return sys_call(&args);
 1fe:	8d 45 ec             	lea    -0x14(%ebp),%eax
 201:	50                   	push   %eax
 202:	e8 fc ff ff ff       	call   203 <isatty+0x18>
			203: R_386_PC32	sys_call
 207:	83 c4 04             	add    $0x4,%esp
}
 20a:	c9                   	leave  
 20b:	c3                   	ret    

0000020c <fstat>:
 * 
 * @param file 
 * @param st 
 * @return int 
 */
int fstat(int file, struct stat *st) {
 20c:	55                   	push   %ebp
 20d:	89 e5                	mov    %esp,%ebp
 20f:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_fstat;
 212:	c7 45 ec 38 00 00 00 	movl   $0x38,-0x14(%ebp)
    args.arg0 = file;
 219:	8b 45 08             	mov    0x8(%ebp),%eax
 21c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = (int)st;
 21f:	8b 45 0c             	mov    0xc(%ebp),%eax
 222:	89 45 f4             	mov    %eax,-0xc(%ebp)

    return sys_call(&args);
 225:	8d 45 ec             	lea    -0x14(%ebp),%eax
 228:	50                   	push   %eax
 229:	e8 fc ff ff ff       	call   22a <fstat+0x1e>
			22a: R_386_PC32	sys_call
 22e:	83 c4 04             	add    $0x4,%esp
}
 231:	c9                   	leave  
 232:	c3                   	ret    

00000233 <sbrk>:
 * @brief 
 * 
 * @param incr 
 * @return void* 
 */
char *sbrk(ptrdiff_t incr) {
 233:	55                   	push   %ebp
 234:	89 e5                	mov    %esp,%ebp
 236:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_sbrk;
 239:	c7 45 ec 3b 00 00 00 	movl   $0x3b,-0x14(%ebp)
    args.arg0 = (int)incr;
 240:	8b 45 08             	mov    0x8(%ebp),%eax
 243:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return (char*)sys_call(&args);
 246:	8d 45 ec             	lea    -0x14(%ebp),%eax
 249:	50                   	push   %eax
 24a:	e8 fc ff ff ff       	call   24b <sbrk+0x18>
			24b: R_386_PC32	sys_call
 24f:	83 c4 04             	add    $0x4,%esp
}
 252:	c9                   	leave  
 253:	c3                   	ret    

00000254 <dup>:
 * @brief 在当前进程的打开文件表中分配新的一项指向该文件描述符对应的文件指针
 * 
 * @param file 需要被多次引用的文件指针的文件描述符
 * @return int 新的文件描述符
 */
int dup(int file) {
 254:	55                   	push   %ebp
 255:	89 e5                	mov    %esp,%ebp
 257:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_dup;
 25a:	c7 45 ec 39 00 00 00 	movl   $0x39,-0x14(%ebp)
    args.arg0 = file;
 261:	8b 45 08             	mov    0x8(%ebp),%eax
 264:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return sys_call(&args);
 267:	8d 45 ec             	lea    -0x14(%ebp),%eax
 26a:	50                   	push   %eax
 26b:	e8 fc ff ff ff       	call   26c <dup+0x18>
			26c: R_386_PC32	sys_call
 270:	83 c4 04             	add    $0x4,%esp
}
 273:	c9                   	leave  
 274:	c3                   	ret    

00000275 <_exit>:
/**
 * @brief 进程退出的系统调用
 * 
 * @param status 
 */
void _exit(int status) {
 275:	55                   	push   %ebp
 276:	89 e5                	mov    %esp,%ebp
 278:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_exit;
 27b:	c7 45 ec 05 00 00 00 	movl   $0x5,-0x14(%ebp)
    args.arg0 = status;
 282:	8b 45 08             	mov    0x8(%ebp),%eax
 285:	89 45 f0             	mov    %eax,-0x10(%ebp)
    
    sys_call(&args);
 288:	8d 45 ec             	lea    -0x14(%ebp),%eax
 28b:	50                   	push   %eax
 28c:	e8 fc ff ff ff       	call   28d <_exit+0x18>
			28d: R_386_PC32	sys_call
 291:	83 c4 04             	add    $0x4,%esp
}
 294:	90                   	nop
 295:	c9                   	leave  
 296:	c3                   	ret    

00000297 <wait>:
 * @brief 回收进程资源
 * 
 * @param status 
 * @return int 
 */
int wait(int *status) {
 297:	55                   	push   %ebp
 298:	89 e5                	mov    %esp,%ebp
 29a:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_wait;
 29d:	c7 45 ec 06 00 00 00 	movl   $0x6,-0x14(%ebp)
    args.arg0 = (int)status;
 2a4:	8b 45 08             	mov    0x8(%ebp),%eax
 2a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    
    return sys_call(&args);
 2aa:	8d 45 ec             	lea    -0x14(%ebp),%eax
 2ad:	50                   	push   %eax
 2ae:	e8 fc ff ff ff       	call   2af <wait+0x18>
			2af: R_386_PC32	sys_call
 2b3:	83 c4 04             	add    $0x4,%esp
}
 2b6:	c9                   	leave  
 2b7:	c3                   	ret    

000002b8 <opendir>:
 * @brief 打开一个目录
 * 
 * @param path 
 * @return DIR* 
 */
DIR *opendir(const char *path) {
 2b8:	55                   	push   %ebp
 2b9:	89 e5                	mov    %esp,%ebp
 2bb:	83 ec 28             	sub    $0x28,%esp
    DIR *dir = (DIR*)malloc(sizeof(DIR));
 2be:	83 ec 0c             	sub    $0xc,%esp
 2c1:	6a 20                	push   $0x20
 2c3:	e8 fc ff ff ff       	call   2c4 <opendir+0xc>
			2c4: R_386_PC32	malloc
 2c8:	83 c4 10             	add    $0x10,%esp
 2cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (dir == (DIR*)0) {
 2ce:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 2d2:	75 07                	jne    2db <opendir+0x23>
        return (DIR*)0;
 2d4:	b8 00 00 00 00       	mov    $0x0,%eax
 2d9:	eb 43                	jmp    31e <opendir+0x66>
    }

    syscall_args_t args;
    args.id = SYS_opendir;
 2db:	c7 45 dc 3c 00 00 00 	movl   $0x3c,-0x24(%ebp)
    args.arg0 = (int)path;
 2e2:	8b 45 08             	mov    0x8(%ebp),%eax
 2e5:	89 45 e0             	mov    %eax,-0x20(%ebp)
    args.arg1 = (int)dir;
 2e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 2eb:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    int err = sys_call(&args);
 2ee:	83 ec 0c             	sub    $0xc,%esp
 2f1:	8d 45 dc             	lea    -0x24(%ebp),%eax
 2f4:	50                   	push   %eax
 2f5:	e8 fc ff ff ff       	call   2f6 <opendir+0x3e>
			2f6: R_386_PC32	sys_call
 2fa:	83 c4 10             	add    $0x10,%esp
 2fd:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (err < 0) {
 300:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 304:	79 15                	jns    31b <opendir+0x63>
        free(dir);
 306:	83 ec 0c             	sub    $0xc,%esp
 309:	ff 75 f4             	push   -0xc(%ebp)
 30c:	e8 fc ff ff ff       	call   30d <opendir+0x55>
			30d: R_386_PC32	free
 311:	83 c4 10             	add    $0x10,%esp
        return (DIR*)0;
 314:	b8 00 00 00 00       	mov    $0x0,%eax
 319:	eb 03                	jmp    31e <opendir+0x66>
    }

    return dir;    
 31b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 31e:	c9                   	leave  
 31f:	c3                   	ret    

00000320 <readdir>:
 * @brief 读取目录信息得到目录项表
 * 
 * @param dir 
 * @return struct dirent* 
 */
struct dirent *readdir(DIR *dir) {
 320:	55                   	push   %ebp
 321:	89 e5                	mov    %esp,%ebp
 323:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_readdir;
 326:	c7 45 e8 3d 00 00 00 	movl   $0x3d,-0x18(%ebp)
    args.arg0 = (int)dir;
 32d:	8b 45 08             	mov    0x8(%ebp),%eax
 330:	89 45 ec             	mov    %eax,-0x14(%ebp)
    args.arg1 = (int)&(dir->dirent);
 333:	8b 45 08             	mov    0x8(%ebp),%eax
 336:	83 c0 04             	add    $0x4,%eax
 339:	89 45 f0             	mov    %eax,-0x10(%ebp)

    int err = sys_call(&args);
 33c:	8d 45 e8             	lea    -0x18(%ebp),%eax
 33f:	50                   	push   %eax
 340:	e8 fc ff ff ff       	call   341 <readdir+0x21>
			341: R_386_PC32	sys_call
 345:	83 c4 04             	add    $0x4,%esp
 348:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if (err < 0) {
 34b:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
 34f:	79 07                	jns    358 <readdir+0x38>
        return (struct dirent*)0;
 351:	b8 00 00 00 00       	mov    $0x0,%eax
 356:	eb 06                	jmp    35e <readdir+0x3e>
    }

    return &dir->dirent;   
 358:	8b 45 08             	mov    0x8(%ebp),%eax
 35b:	83 c0 04             	add    $0x4,%eax
}
 35e:	c9                   	leave  
 35f:	c3                   	ret    

00000360 <closedir>:
 * @brief 关闭目录
 * 
 * @param dir 
 * @return int 
 */
int closedir(DIR *dir) {
 360:	55                   	push   %ebp
 361:	89 e5                	mov    %esp,%ebp
 363:	83 ec 28             	sub    $0x28,%esp
    syscall_args_t args;
    args.id = SYS_closedir;
 366:	c7 45 e0 3e 00 00 00 	movl   $0x3e,-0x20(%ebp)
    args.arg0 = (int)dir;
 36d:	8b 45 08             	mov    0x8(%ebp),%eax
 370:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    int err = sys_call(&args);
 373:	8d 45 e0             	lea    -0x20(%ebp),%eax
 376:	50                   	push   %eax
 377:	e8 fc ff ff ff       	call   378 <closedir+0x18>
			378: R_386_PC32	sys_call
 37c:	83 c4 04             	add    $0x4,%esp
 37f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    free(dir);
 382:	83 ec 0c             	sub    $0xc,%esp
 385:	ff 75 08             	push   0x8(%ebp)
 388:	e8 fc ff ff ff       	call   389 <closedir+0x29>
			389: R_386_PC32	free
 38d:	83 c4 10             	add    $0x10,%esp

    return err;   
 390:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 393:	c9                   	leave  
 394:	c3                   	ret    

00000395 <ioctl>:
 * @param cmd 
 * @param arg0 
 * @param arg1 
 * @return int 
 */
int ioctl(int file, int cmd, int arg0, int arg1) {
 395:	55                   	push   %ebp
 396:	89 e5                	mov    %esp,%ebp
 398:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_ioctl;
 39b:	c7 45 e8 3a 00 00 00 	movl   $0x3a,-0x18(%ebp)
    args.arg0 = file;
 3a2:	8b 45 08             	mov    0x8(%ebp),%eax
 3a5:	89 45 ec             	mov    %eax,-0x14(%ebp)
    args.arg1 = cmd;
 3a8:	8b 45 0c             	mov    0xc(%ebp),%eax
 3ab:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg2 = arg0;
 3ae:	8b 45 10             	mov    0x10(%ebp),%eax
 3b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg3 = arg1;
 3b4:	8b 45 14             	mov    0x14(%ebp),%eax
 3b7:	89 45 f8             	mov    %eax,-0x8(%ebp)

    int err = sys_call(&args);
 3ba:	8d 45 e8             	lea    -0x18(%ebp),%eax
 3bd:	50                   	push   %eax
 3be:	e8 fc ff ff ff       	call   3bf <ioctl+0x2a>
			3bf: R_386_PC32	sys_call
 3c3:	83 c4 04             	add    $0x4,%esp
 3c6:	89 45 fc             	mov    %eax,-0x4(%ebp)

    return err;   
 3c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
 3cc:	c9                   	leave  
 3cd:	c3                   	ret    
