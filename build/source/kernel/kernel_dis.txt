
/home/kbpoyo/code/cpp/MyOs/build/source/kernel/kernel.elf:     file format elf32-i386
/home/kbpoyo/code/cpp/MyOs/build/source/kernel/kernel.elf
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00010000

Program Header:
    LOAD off    0x00001000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x000000f6 memsz 0x00010100 flags rwx
   STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4
         filesz 0x00000000 memsz 0x00000000 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000f6  00010000  00010000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00010000  00010100  00010100  000010f6  2**5
                  ALLOC
  2 .debug_line   00000184  00000000  00000000  000010f6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  3 .debug_line_str 00000172  00000000  00000000  0000127a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  4 .debug_info   00000289  00000000  00000000  000013ec  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  5 .debug_abbrev 000001dc  00000000  00000000  00001675  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  6 .debug_aranges 00000060  00000000  00000000  00001858  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_str    0000020a  00000000  00000000  000018b8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .comment      0000002b  00000000  00000000  00001ac2  2**0
                  CONTENTS, READONLY
  9 .debug_frame  000000a0  00000000  00000000  00001af0  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 cpu.c
00010100 l     O .bss	00010000 gdt_table
000100a6 l     F .text	00000038 gdt_init
00000000 l    df *ABS*	00000000 init.c
000100de g     F .text	0000000b cpu_init
000100e9 g     F .text	0000000d kernel_init
00010000 g       .text	00000000 _start
0001000d g     F .text	00000099 segment_desc_set



Disassembly of section .text:

00010000 <_start>:
*            [&boot_info]
*    esp ->  [返回地址]
*   所以要想访问到&boot_info，则只需从当前esp的位置偏移+4字节即可
*/
_start:
    mov %esp, %ebp      //栈空间最好只用ebp来进行偏移访问
   10000:	89 e5                	mov    %esp,%ebp
    mov 0x4(%ebp), %eax //将&boot_info的值存入eax中
   10002:	8b 45 04             	mov    0x4(%ebp),%eax

    push %eax           //外部函数将参数压入栈中，再进行函数调用
   10005:	50                   	push   %eax
    call kernel_init    //调用内核初始化函数
   10006:	e8 de 00 00 00       	call   100e9 <kernel_init>
    jmp .
   1000b:	eb fe                	jmp    1000b <_start+0xb>

0001000d <segment_desc_set>:
 *                 即2的13次方个段，也就是8192
 * @param base 该段在内存中的真实段基址
 * @param limit 该段的段界限，是一个偏移量，表示段中最大的偏移界限
 * @param attr 该段的属性位
 */
void segment_desc_set(uint16_t selector,  uint32_t base, uint32_t limit, uint16_t attr) {
   1000d:	55                   	push   %ebp
   1000e:	89 e5                	mov    %esp,%ebp
   10010:	83 ec 18             	sub    $0x18,%esp
   10013:	8b 55 08             	mov    0x8(%ebp),%edx
   10016:	8b 45 14             	mov    0x14(%ebp),%eax
   10019:	66 89 55 ec          	mov    %dx,-0x14(%ebp)
   1001d:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
    //1. 获取该段描述符在内存中的起始地址，selector >> 3 取出3~15位才是其在全局描述符中的下标
    segment_desc_t *desc = gdt_table + (selector >> 3);
   10021:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   10025:	66 c1 e8 03          	shr    $0x3,%ax
   10029:	0f b7 c0             	movzwl %ax,%eax
   1002c:	c1 e0 03             	shl    $0x3,%eax
   1002f:	05 00 01 01 00       	add    $0x10100,%eax
   10034:	89 45 fc             	mov    %eax,-0x4(%ebp)

    //2. 设置段基地址
    desc->base15_0 = (uint16_t)base;
   10037:	8b 45 0c             	mov    0xc(%ebp),%eax
   1003a:	89 c2                	mov    %eax,%edx
   1003c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1003f:	66 89 50 02          	mov    %dx,0x2(%eax)
    desc->base23_16 = (uint8_t)(base >> 16);
   10043:	8b 45 0c             	mov    0xc(%ebp),%eax
   10046:	c1 e8 10             	shr    $0x10,%eax
   10049:	89 c2                	mov    %eax,%edx
   1004b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1004e:	88 50 04             	mov    %dl,0x4(%eax)
    desc->base31_24 = (uint8_t)(base >> 24);
   10051:	8b 45 0c             	mov    0xc(%ebp),%eax
   10054:	c1 e8 18             	shr    $0x18,%eax
   10057:	89 c2                	mov    %eax,%edx
   10059:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1005c:	88 50 07             	mov    %dl,0x7(%eax)

    //3. 设置段界限
    desc->limit15_0 = (uint16_t)limit;
   1005f:	8b 45 10             	mov    0x10(%ebp),%eax
   10062:	89 c2                	mov    %eax,%edx
   10064:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10067:	66 89 10             	mov    %dx,(%eax)
    desc->attr |= ((uint16_t)(limit >> 8) & 0x0f00); //将limit高4位赋值到attr的8~11位(段界限的高4位)
   1006a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1006d:	0f b7 40 05          	movzwl 0x5(%eax),%eax
   10071:	89 c2                	mov    %eax,%edx
   10073:	8b 45 10             	mov    0x10(%ebp),%eax
   10076:	c1 e8 08             	shr    $0x8,%eax
   10079:	66 25 00 0f          	and    $0xf00,%ax
   1007d:	09 d0                	or     %edx,%eax
   1007f:	89 c2                	mov    %eax,%edx
   10081:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10084:	66 89 50 05          	mov    %dx,0x5(%eax)

    //4.设置属性位
    desc->attr |= attr & 0xf0ff;
   10088:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1008b:	0f b7 40 05          	movzwl 0x5(%eax),%eax
   1008f:	89 c2                	mov    %eax,%edx
   10091:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
   10095:	80 e4 f0             	and    $0xf0,%ah
   10098:	09 d0                	or     %edx,%eax
   1009a:	89 c2                	mov    %eax,%edx
   1009c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1009f:	66 89 50 05          	mov    %dx,0x5(%eax)


}
   100a3:	90                   	nop
   100a4:	c9                   	leave  
   100a5:	c3                   	ret    

000100a6 <gdt_init>:

/**
 * @brief  初始化GDT
 * 
 */
static void gdt_init(void) {
   100a6:	55                   	push   %ebp
   100a7:	89 e5                	mov    %esp,%ebp
   100a9:	83 ec 10             	sub    $0x10,%esp
    //TODO:暂时将所有段都初始化为0
    for (int i = 0; i < GDT_TABLE_SIZE; ++i) {
   100ac:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   100b3:	eb 1c                	jmp    100d1 <gdt_init+0x2b>
        segment_desc_set(i << 3, 0, 0, 0);
   100b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   100b8:	c1 e0 03             	shl    $0x3,%eax
   100bb:	0f b7 c0             	movzwl %ax,%eax
   100be:	6a 00                	push   $0x0
   100c0:	6a 00                	push   $0x0
   100c2:	6a 00                	push   $0x0
   100c4:	50                   	push   %eax
   100c5:	e8 43 ff ff ff       	call   1000d <segment_desc_set>
   100ca:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < GDT_TABLE_SIZE; ++i) {
   100cd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   100d1:	81 7d fc ff 1f 00 00 	cmpl   $0x1fff,-0x4(%ebp)
   100d8:	7e db                	jle    100b5 <gdt_init+0xf>
    }
}
   100da:	90                   	nop
   100db:	90                   	nop
   100dc:	c9                   	leave  
   100dd:	c3                   	ret    

000100de <cpu_init>:

/**
 * @brief  初始化cpu相关属性
 * 
 */
void cpu_init(void) {
   100de:	55                   	push   %ebp
   100df:	89 e5                	mov    %esp,%ebp
    gdt_init();
   100e1:	e8 c0 ff ff ff       	call   100a6 <gdt_init>

}
   100e6:	90                   	nop
   100e7:	5d                   	pop    %ebp
   100e8:	c3                   	ret    

000100e9 <kernel_init>:

/**
 * @brief  对内核进行初始化操作
 * 
 */
void kernel_init(_boot_info_t_* boot_info) {
   100e9:	55                   	push   %ebp
   100ea:	89 e5                	mov    %esp,%ebp
   100ec:	83 ec 08             	sub    $0x8,%esp
    //1.对cpu相关属性进行初始化
    cpu_init();
   100ef:	e8 ea ff ff ff       	call   100de <cpu_init>

    
    for (;;){}
   100f4:	eb fe                	jmp    100f4 <kernel_init+0xb>
