
/home/kbpoyo/code/cpp/MyOs/build/source/shell/shell.elf:     file format elf32-i386
/home/kbpoyo/code/cpp/MyOs/build/source/shell/shell.elf
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x81000193

Program Header:
    LOAD off    0x00001000 vaddr 0x81000000 paddr 0x81000000 align 2**12
         filesz 0x000001fa memsz 0x000001fa flags r-x
   STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4
         filesz 0x00000000 memsz 0x00000000 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000001bd  81000000  81000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       0000003d  810001bd  810001bd  000011bd  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .debug_info   00000302  00000000  00000000  000011fa  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  3 .debug_abbrev 000001e0  00000000  00000000  000014fc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  4 .debug_aranges 00000060  00000000  00000000  000016e0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  5 .debug_line   000001bf  00000000  00000000  00001740  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  6 .debug_str    00000195  00000000  00000000  000018ff  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_line_str 00000187  00000000  00000000  00001a94  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .comment      00000058  00000000  00000000  00001c1b  2**0
                  CONTENTS, READONLY
  9 .debug_frame  0000012c  00000000  00000000  00001c74  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 main.c
81000000 l     F .text	0000004c sys_call
8100004c l     F .text	0000002a msleep
81000076 l     F .text	0000001b getpid
81000091 l     F .text	00000028 print_msg
810000b9 l     F .text	0000001b fork
810000d4 l     F .text	0000001b yield
00000000 l    df *ABS*	00000000 cstart.c
81000193 g       .text	00000000 _start
810001a3 g     F .text	0000001a cstart
810000ef g     F .text	000000a4 main



Disassembly of section .text:

81000000 <sys_call>:
}syscall_args_t;




static inline int sys_call(syscall_args_t *args) {
81000000:	55                   	push   %ebp
81000001:	89 e5                	mov    %esp,%ebp
81000003:	57                   	push   %edi
81000004:	56                   	push   %esi
81000005:	53                   	push   %ebx
81000006:	83 ec 10             	sub    $0x10,%esp
    // 传入远跳转需要的参数, 即cs = selector, eip = offset 
    //为调用门选择子赋予0特权级,调用门的 cpl 和 RPL <= 系统调用段描述符的DPL
    //门描述符中目标选择子的 CPL <= 门描述符的 DPL
    uint32_t addr[] = {0, SYSCALL_SELECTOR | 0};  
81000009:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
81000010:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%ebp)
        "push %[arg1]\n\t"
        "push %[arg0]\n\t"
        "push %[id]\n\t"
        "lcalll *(%[addr])\n\t"
        :"=a"(ret)
        :[arg3]"r"(args->arg3), 
81000017:	8b 45 08             	mov    0x8(%ebp),%eax
8100001a:	8b 40 10             	mov    0x10(%eax),%eax
         [arg2]"r"(args->arg2), 
8100001d:	8b 55 08             	mov    0x8(%ebp),%edx
81000020:	8b 52 0c             	mov    0xc(%edx),%edx
         [arg1]"r"(args->arg1),
81000023:	8b 4d 08             	mov    0x8(%ebp),%ecx
81000026:	8b 49 08             	mov    0x8(%ecx),%ecx
         [arg0]"r"(args->arg0), 
81000029:	8b 5d 08             	mov    0x8(%ebp),%ebx
8100002c:	8b 5b 04             	mov    0x4(%ebx),%ebx
         [id]"r"(args->id), 
8100002f:	8b 75 08             	mov    0x8(%ebp),%esi
81000032:	8b 36                	mov    (%esi),%esi
     __asm__ __volatile__(
81000034:	8d 7d e8             	lea    -0x18(%ebp),%edi
81000037:	50                   	push   %eax
81000038:	52                   	push   %edx
81000039:	51                   	push   %ecx
8100003a:	53                   	push   %ebx
8100003b:	56                   	push   %esi
8100003c:	ff 1f                	lcall  *(%edi)
8100003e:	89 45 f0             	mov    %eax,-0x10(%ebp)
         [addr]"r"(addr)
    );

    return ret;
81000041:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
81000044:	83 c4 10             	add    $0x10,%esp
81000047:	5b                   	pop    %ebx
81000048:	5e                   	pop    %esi
81000049:	5f                   	pop    %edi
8100004a:	5d                   	pop    %ebp
8100004b:	c3                   	ret    

8100004c <msleep>:
/**
 * @brief 以ms为单位进行延时
 * 
 * @param ms 
 */
static inline void msleep(int ms) {
8100004c:	55                   	push   %ebp
8100004d:	89 e5                	mov    %esp,%ebp
8100004f:	83 ec 20             	sub    $0x20,%esp
    if (ms <= 0) return;
81000052:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
81000056:	7e 1b                	jle    81000073 <msleep+0x27>

    syscall_args_t args;
    args.id = SYS_sleep;
81000058:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    args.arg0 = ms;
8100005f:	8b 45 08             	mov    0x8(%ebp),%eax
81000062:	89 45 f0             	mov    %eax,-0x10(%ebp)

    sys_call(&args);
81000065:	8d 45 ec             	lea    -0x14(%ebp),%eax
81000068:	50                   	push   %eax
81000069:	e8 92 ff ff ff       	call   81000000 <sys_call>
8100006e:	83 c4 04             	add    $0x4,%esp
81000071:	eb 01                	jmp    81000074 <msleep+0x28>
    if (ms <= 0) return;
81000073:	90                   	nop

}
81000074:	c9                   	leave  
81000075:	c3                   	ret    

81000076 <getpid>:
/**
 * @brief 获取用户进程id
 * 
 * @return int 
 */
static inline int getpid(void) {
81000076:	55                   	push   %ebp
81000077:	89 e5                	mov    %esp,%ebp
81000079:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_getpid;
8100007c:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

    return sys_call(&args);
81000083:	8d 45 ec             	lea    -0x14(%ebp),%eax
81000086:	50                   	push   %eax
81000087:	e8 74 ff ff ff       	call   81000000 <sys_call>
8100008c:	83 c4 04             	add    $0x4,%esp
}
8100008f:	c9                   	leave  
81000090:	c3                   	ret    

81000091 <print_msg>:

static inline void print_msg(const char *fmt, int arg) {
81000091:	55                   	push   %ebp
81000092:	89 e5                	mov    %esp,%ebp
81000094:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_printmsg;
81000097:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
    args.arg0 = (int)fmt;
8100009e:	8b 45 08             	mov    0x8(%ebp),%eax
810000a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = arg;
810000a4:	8b 45 0c             	mov    0xc(%ebp),%eax
810000a7:	89 45 f4             	mov    %eax,-0xc(%ebp)

    sys_call(&args);
810000aa:	8d 45 ec             	lea    -0x14(%ebp),%eax
810000ad:	50                   	push   %eax
810000ae:	e8 4d ff ff ff       	call   81000000 <sys_call>
810000b3:	83 c4 04             	add    $0x4,%esp
}
810000b6:	90                   	nop
810000b7:	c9                   	leave  
810000b8:	c3                   	ret    

810000b9 <fork>:

static inline int fork (void) {
810000b9:	55                   	push   %ebp
810000ba:	89 e5                	mov    %esp,%ebp
810000bc:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_fork;
810000bf:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)

    return sys_call(&args);
810000c6:	8d 45 ec             	lea    -0x14(%ebp),%eax
810000c9:	50                   	push   %eax
810000ca:	e8 31 ff ff ff       	call   81000000 <sys_call>
810000cf:	83 c4 04             	add    $0x4,%esp
}
810000d2:	c9                   	leave  
810000d3:	c3                   	ret    

810000d4 <yield>:
/**
 * @brief 进程主动放弃cpu
 * 
 * @return int 
 */
static inline int yield (void) {
810000d4:	55                   	push   %ebp
810000d5:	89 e5                	mov    %esp,%ebp
810000d7:	83 ec 20             	sub    $0x20,%esp
    syscall_args_t args;
    args.id = SYS_yield;
810000da:	c7 45 ec 04 00 00 00 	movl   $0x4,-0x14(%ebp)

    return sys_call(&args);
810000e1:	8d 45 ec             	lea    -0x14(%ebp),%eax
810000e4:	50                   	push   %eax
810000e5:	e8 16 ff ff ff       	call   81000000 <sys_call>
810000ea:	83 c4 04             	add    $0x4,%esp
}
810000ed:	c9                   	leave  
810000ee:	c3                   	ret    

810000ef <main>:
 * 
 */

#include "lib_syscall.h"

int main(int argc, char** argv) {
810000ef:	55                   	push   %ebp
810000f0:	89 e5                	mov    %esp,%ebp
810000f2:	83 ec 10             	sub    $0x10,%esp
    print_msg("main pid %d", getpid());
810000f5:	e8 7c ff ff ff       	call   81000076 <getpid>
810000fa:	50                   	push   %eax
810000fb:	68 bd 01 00 81       	push   $0x810001bd
81000100:	e8 8c ff ff ff       	call   81000091 <print_msg>
81000105:	83 c4 08             	add    $0x8,%esp
    for (int i = 0; i < argc; ++i) {
81000108:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
8100010f:	eb 23                	jmp    81000134 <main+0x45>
        print_msg("arg: %s", argv[i]);
81000111:	8b 45 fc             	mov    -0x4(%ebp),%eax
81000114:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
8100011b:	8b 45 0c             	mov    0xc(%ebp),%eax
8100011e:	01 d0                	add    %edx,%eax
81000120:	8b 00                	mov    (%eax),%eax
81000122:	50                   	push   %eax
81000123:	68 c9 01 00 81       	push   $0x810001c9
81000128:	e8 64 ff ff ff       	call   81000091 <print_msg>
8100012d:	83 c4 08             	add    $0x8,%esp
    for (int i = 0; i < argc; ++i) {
81000130:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
81000134:	8b 45 fc             	mov    -0x4(%ebp),%eax
81000137:	3b 45 08             	cmp    0x8(%ebp),%eax
8100013a:	7c d5                	jl     81000111 <main+0x22>
    }

    int pid = fork();
8100013c:	e8 78 ff ff ff       	call   810000b9 <fork>
81000141:	89 45 f8             	mov    %eax,-0x8(%ebp)
    yield();
81000144:	e8 8b ff ff ff       	call   810000d4 <yield>
    if (pid > 0) print_msg("parent pid=%d", pid);
81000149:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
8100014d:	7e 12                	jle    81000161 <main+0x72>
8100014f:	ff 75 f8             	push   -0x8(%ebp)
81000152:	68 d1 01 00 81       	push   $0x810001d1
81000157:	e8 35 ff ff ff       	call   81000091 <print_msg>
8100015c:	83 c4 08             	add    $0x8,%esp
8100015f:	eb 10                	jmp    81000171 <main+0x82>
    else print_msg("chiled pid=%d", pid);
81000161:	ff 75 f8             	push   -0x8(%ebp)
81000164:	68 df 01 00 81       	push   $0x810001df
81000169:	e8 23 ff ff ff       	call   81000091 <print_msg>
8100016e:	83 c4 08             	add    $0x8,%esp

    for (;;) {
        print_msg("shell pid=%d", getpid());
81000171:	e8 00 ff ff ff       	call   81000076 <getpid>
81000176:	50                   	push   %eax
81000177:	68 ed 01 00 81       	push   $0x810001ed
8100017c:	e8 10 ff ff ff       	call   81000091 <print_msg>
81000181:	83 c4 08             	add    $0x8,%esp
        msleep(1000);
81000184:	68 e8 03 00 00       	push   $0x3e8
81000189:	e8 be fe ff ff       	call   8100004c <msleep>
8100018e:	83 c4 04             	add    $0x4,%esp
        print_msg("shell pid=%d", getpid());
81000191:	eb de                	jmp    81000171 <main+0x82>

81000193 <_start>:
    .extern cstart
_start:
    //iret指令返回后，将之前压入的 ss,esp,eflags,cs,eip 寄存器值返回给对应寄存器，
	//由于cpu从0特权级切换到了3特权级，而之前其余的段寄存器都是0特权级，不能供3特权级使用，
	//所以cpu将其余寄存器置零，这里直接用ss寄存器再初始化其余段寄存器即可
	mov %ss, %ax
81000193:	66 8c d0             	mov    %ss,%ax
	mov %ax, %ds
81000196:	8e d8                	mov    %eax,%ds
	mov %ax, %es
81000198:	8e c0                	mov    %eax,%es
	mov %ax, %fs
8100019a:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
8100019c:	8e e8                	mov    %eax,%gs

    //因为cs寄存器已由操作系统分配，所以直接跳转即可
	jmp cstart
8100019e:	e9 00 00 00 00       	jmp    810001a3 <cstart>

810001a3 <cstart>:
 * @brief 执行调用main之前的初始化工作
 *
 * @param argc
 * @param argv
 */
void cstart(int argc, char **argv) {
810001a3:	55                   	push   %ebp
810001a4:	89 e5                	mov    %esp,%ebp
810001a6:	83 ec 08             	sub    $0x8,%esp
    main(argc, argv);
810001a9:	83 ec 08             	sub    $0x8,%esp
810001ac:	ff 75 0c             	push   0xc(%ebp)
810001af:	ff 75 08             	push   0x8(%ebp)
810001b2:	e8 38 ff ff ff       	call   810000ef <main>
810001b7:	83 c4 10             	add    $0x10,%esp
}
810001ba:	90                   	nop
810001bb:	c9                   	leave  
810001bc:	c3                   	ret    
